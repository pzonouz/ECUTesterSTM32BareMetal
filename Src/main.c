/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include "delay.h"
#include <stdint.h>
#include "stm32f0xx.h"
#include "LCD1602A.h"


#define DUTY_CYCLE 0.5

//static __IO uint32_t adcValue;
//int calibration_factor;
static __IO uint32_t rpm;
//static __IO uint32_t rpm;
uint32_t adc_counter=0;
uint32_t adc_sum=0;

int main(void)
{
	//	Set SysTick for create 10 microsecond delay
	if(SysTick_Config(48000000/100000))
	{
		while(1);
	}
	//FLASH
	FLASH->ACR|=FLASH_ACR_LATENCY;
	FLASH->ACR|=FLASH_ACR_PRFTBE;
	while(!(FLASH->ACR&FLASH_ACR_PRFTBS));
	//CLOCK
	RCC->CR|=RCC_CR_HSEON;
	while(!(RCC->CR&RCC_CR_HSERDY));
	RCC->CFGR|=RCC_CFGR_PLLMUL6;
	RCC->CFGR|=RCC_CFGR_PLLSRC_HSE_PREDIV;
	RCC->CR|=RCC_CR_PLLON;
	while(!(RCC->CR|=RCC_CR_PLLRDY));
	//	RCC->CFGR|=RCC_CFGR_SWS_HSE;
	//	while(!(RCC->CFGR&RCC_CFGR_SWS_HSE));
	RCC->CFGR|=RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR&RCC_CFGR_SWS_PLL));
	RCC->CR|=RCC_CR2_HSI14ON;
	while(!(RCC->CR2|=RCC_CR2_HSI14RDY));

	RCC->APB2ENR|=RCC_APB2ENR_ADCEN;
	//	ADC1->CFGR2|=ADC_CFGR2_CKMODE_0;
	RCC->AHBENR|=RCC_AHBENR_GPIOAEN;
	//GPIO
	GPIOA->MODER|=GPIO_MODER_MODER4_0;
	GPIOA->PUPDR|=GPIO_PUPDR_PUPDR4_0;
	GPIOA->OSPEEDR|=GPIO_OSPEEDER_OSPEEDR1;
	GPIOA->ODR|=GPIO_ODR_4;
	GPIOA->MODER|=GPIO_MODER_MODER5;
	//NVIC
	//	NVIC_EnableIRQ(ADC1_COMP_IRQn);
	//	NVIC_SetPriority(ADC1_COMP_IRQn,0);
	//LCD1602A
	while(initLC1602A());
	//ADC
	ADC1->CR&=~ADC_CR_ADEN;
	ADC1->SMPR|=ADC_SMPR1_SMPR_2;
	ADC1->CFGR1|=ADC_CFGR1_CONT;
	ADC1->IER|=ADC_IER_EOSIE;
	ADC1->CHSELR|=ADC_CHSELR_CHSEL5;
	//	for(int i=0;i<10;i++);
	//	ADC1->CR|=ADC_CR_ADCAL;
	//	while(ADC1->CR&ADC_CR_ADCAL);
	//	calibration_factor=ADC1->DR;
	for(int i=0;i<10;i++);
	ADC1->ISR|=ADC_ISR_ADRDY;
	ADC1->CR|=ADC_CR_ADEN;
	while(!(ADC1->ISR&=ADC_ISR_ADRDY));
	ADC1->CR|=ADC_CR_ADSTART;
	/* Loop forever */
	int counter=0;
	while(1){
		if(rpm<250){rpm=250;}
		int T=10000/rpm;
		int OnDelay=T;
		int OffDelay=T;
		GPIOA->ODR &=~GPIO_ODR_4;
		Delay_10us(OffDelay);
		GPIOA->ODR|=GPIO_ODR_4;
		Delay_10us(OnDelay);
		counter++;
		if(counter==59)
		{
			GPIOA->ODR &=~GPIO_ODR_4;
			Delay_10us(2*T);
			counter=0;
			continue;
		}
	}
}

void ADC_IRQHandler()
{
	if(ADC1->ISR & ADC_ISR_EOC)
	{
		//Handle end of conversion
		ADC1->ISR = ADC_ISR_EOC;
	}
	if(ADC1->ISR & ADC_ISR_EOSEQ)
	{
//		if(adc_counter==999)
//		{
//			rpm=adc_sum*10/4095;
//		}
		rpm=adc_sum*10000/4095;
//		adc_sum=ADC1->DR + adc_sum;
//		adc_counter++;
		ADC1->ISR = ADC_ISR_EOSEQ;
	}

}




